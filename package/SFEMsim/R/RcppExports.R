# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Apply a function defined in R to a vector
#'
#'@param f Pointer to a Funct object.
#'@param x Numerical vector.
#'
#'@return The numerical vector f(x).
#'
#'@keywords internal
#'
NULL

#' Initialize vector for computation of coefficents of Chebyshev approximation by FFT
#'
#'@param f Pointer to a Funct object. Function to be approximated.
#'@param theta Numerical vector. Discretisation of the interval [0,2*pi].
#'@param a,b Real numbers. Interval on which the approximation is carried out.
#'
#'@return A matrix whose both columns are used to compute the coefficients using FFT.
#'
#'@keywords internal
#'
NULL

#' Computation of coefficents of Chebyshev approximation by FFT
#'
#'@param h Pointer to a Funct object. Function to be approximated.
#'@param M Integer. Order of the polynomial approximation.
#'@param a,b Real numbers. Interval on which the approximation is carried out.
#'@param minSubdiv Integer. Minimal number of discretisation points.
#'@param verbose Integer. Print messages if \code{verbose=1}.
#'
#'@return A vector containing the \code{M+1} coefficients of the Chebyshev approximation of \code{h} over [\code{a},\code{b}].
#'
#'@keywords internal
#'
NULL

#'Coefficents of Chebyshev approximation by FFT
#'
#' Computation of the coefficents of Chebyshev approximation of a function over a given interval (by FFT).
#'
#'@param h R numerical function. Function to be approximated.
#'@param M Integer. Order of the polynomial approximation.
#'@param a,b Real numbers. Interval on which the approximation is carried out.
#'@param minSubdiv Integer. Minimal number of discretisation points.
#'@param verbose Integer. Print messages if \code{verbose=1}.
#'
#'@return A vector containing the \code{M+1} coefficients of the Chebyshev approximation of \code{h} over [\code{a},\code{b}].
#'
#'@examples
#'f<-function(x){
#' (1+x)**(-2)
#'}
#'coefsChebApprox(f,M=100,a=0,b=50)
#'
coefsChebApprox <- function(h_, M, a, b, verbose = 0L) {
    .Call('_SFEMsim_coefsChebApprox', PACKAGE = 'SFEMsim', h_, M, a, b, verbose)
}

#' Product of a Chebyshev matrix polynomial and  vectors
#'
#' \code{prodChebDecompVec} computes the product of a Chebyshev decomposition evaluated at a matrix and vectors binded in a matrix.
#'
#'@param S A sparse matrix.
#'@param Coefs A numeric vector. Coeffcients of a Chebyshev decomposition.
#'@param a,b Real numbers. Interval on which the Chebyshev polynomials are shifted. Default : \code{a=-1.0}, \code{b=1.0}.
#'@param V A matrix.
#'
#'@details This function computes the product
#'\deqn{\sum_{i=0}^{M-1} \mathtt{Coefs}[i+1]T_i(\frac{2}{b-a}S-\frac{a+b}{b-a}I)V}
#'where \code{M=length(Coefs)}, \eqn{I} is trhe identity matrix, \eqn{T_i} is the i-th Chebyshev poynomial.
#'
#'@return A matrix such that each column is the product of the evaluation at the matrix \code{S} of the Chebyshev decomposition, and a column of \code{V}. The coefficients of the decompostion are defined in \code{Coefs}.
#'
#'
prodChebDecompVec <- function(S, Coefs, a, b, V) {
    .Call('_SFEMsim_prodChebDecompVec', PACKAGE = 'SFEMsim', S, Coefs, a, b, V)
}

#' Chebyshev Polynomial
#'
#' \code{evalCheb} returns the value of a Chebyshev polynomial evaluated at one (or several) point(s).
#'
#'@param x A real number or a vector.
#'@param n An integer. Order of the Chebyshev polynomial.
#'@param a,b Real numbers. Interval on which the Chebyshev polynomial is shifted. Default : \code{a=-1.0}, \code{b=1.0}.
#'
#'@return The evaluation at \code{x} of the \code{n}-th Chebyshev polynomial, shifted to interval \code{[a,b]}.
#'
#'@details This function computes
#'\eqn{T_n(\frac{2}{b-a}x-\frac{a+b}{b-a})}
#'where \eqn{T_n} is the n-th Chebyshev poynomial.
#'
#'
#'@examples
#'evalCheb(x=runif(10,-2,2), n=10, a=-2, b=2)
#'
evalCheb <- function(x, n, a = -1.0, b = 1.0) {
    .Call('_SFEMsim_evalCheb', PACKAGE = 'SFEMsim', x, n, a, b)
}

#' Evaluation of a Chebyshev decomposition
#'
#' \code{evalChebDecompPts} returns the value of a Chebyshev decomposition evaluated at several points.
#'
#'@param x A numeric vector.
#'@param Coefs A numeric vector. Coeffcients of a Chebyshev decomposition.
#'@param a,b Real numbers. Interval on which the Chebyshev polynomials are shifted. Default : \code{a=-1.0}, \code{b=1.0}.
#'
#'@details This function computes
#'\deqn{\sum_{i=0}^{M-1} \mathtt{Coefs}[i+1]T_i(\frac{2}{b-a}x-\frac{a+b}{b-a})}
#'where \code{M=length(Coefs)}, \eqn{T_i} is the i-th Chebyshev poynomial.
#'
#'@return The evaluation at each component of \code{x} of the Chebyshev decomposition whose coefficients are defined in \code{Coefs}.
#'
#'@examples
#'curve(evalChebDecompPts(x=x,Coefs=runif(5),a=-2,b=2),-2,2)
#'
evalChebDecompPts <- function(x, Coefs, a, b) {
    .Call('_SFEMsim_evalChebDecompPts', PACKAGE = 'SFEMsim', x, Coefs, a, b)
}

#' Evaluation of a Chebyshev decomposition
#'
#' \code{evalChebDecompMat} returns the value of a Chebyshev decomposition evaluated at a matrix.
#'
#'@param S A sparse matrix.
#'@param Coefs A numeric vector. Coeffcients of a Chebyshev decomposition.
#'@param a,b Real numbers. Interval on which the Chebyshev polynomials are shifted. Default : \code{a=-1.0}, \code{b=1.0}.
#'
#'@details This function computes
#'\deqn{\sum_{i=0}^{M-1} \mathtt{Coefs}[i+1]T_i(\frac{2}{b-a}S-\frac{a+b}{b-a}I)}
#'where \code{M=length(Coefs)}, \eqn{I} is the indentity matrix, \eqn{T_i} is the i-th Chebyshev poynomial.
#'
#'
#'@return The evaluation at each component at the matrix \code{S} of the Chebyshev decomposition whose coefficients are defined in \code{Coefs}.
#'
evalChebDecompMat <- function(S, Coefs, a, b) {
    .Call('_SFEMsim_evalChebDecompMat', PACKAGE = 'SFEMsim', S, Coefs, a, b)
}

#' Mass and stiffness matrices for 2D surfaces
#'
#' Computes the mass and stiffness matrices associated with a second-order elliptic symmetric operator \eqn{L=-\text{div}(A \nabla) + V}.
#'
#'@param nodeMat Array containing the coordinates of the triangulation nodes
#'@param triMat Array containing, for each triangle, the node indices (starting at 1).
#'@param triMetricMat Array containing, for each triangle, the coefficients of the metric tensor of each triangle.
#'@param triPotCoeffs Array containing, for each triangle, the value of the potential function \eqn{V}. If set to \code{NULL} (Default), no potential function is considered.
#'@param triDiffCoeffs Array containing, for each triangle, the coefficients of the modified metric tensor associated with the diffusion matrix \eqn{A}. If set to \code{NULL} (Default), the usual metric is considered (which corresponds to the case where \eq{A} is the identity matrix).
#'@param massLumping logical; TRUE (Default) = Compute mass lumping approximation of mass matrix, FALSE = Compute true mass matrix.
#'
#'@details We consider second-order elliptic symmetric operators \eqn{L} of the form \deqn{L=-\text{div}(A \nabla) + V} where \eqn{V} denotes a so-called potential function taking postive values,
#' \eqn{A} denotes a (linear) operator mapping tangent vectors at a given point to tangent vectors at the same point, \eqn{\test{div}} denotes the divergence operator, and \eqn{\nabla} denotes the gradient operator.
#'
#'@details The function returns the mass and stiffness matrices associated with linear finite elements on a mesh. The mass matrix \eqn{C} contains entries \eqn{[(\psi_i, \psi_j)]_{1 \le i,j \le n}},
#' the mass lumped matrix  \eqn{\hat{C}} is diagonal with entries \eqn{[(\psi_i, 1)]_{1 \le i\le n}},
#' the stiffness matrix \eqn{R} contains entries \eqn{[(V\psi_i, \psi_j)+(A\nabla\psi_i, \nabla\psi_j)]_{1 \le i,j \le n}}
#' The scaled stiffness matrix is defined as \eqn{S=\hat{C}^{-1/2}R\hat{C}^{-1/2}}.
#'
#'@details The coefficients in \code{triMetricMat} can be computed using the functions \code{triMetricSph} and \code{triMetricPull}.
#' The coefficients in \code{triPotCoeffs} can be computed using the function \code{triPot}.
#'
#'@details The coefficients in \code{triDiffCoeffs} correspond to the overall tensor, in local coordinates, that allows us to compute the
#'\eqn{(A\nabla\psi_i, \nabla\psi_j)} using the gradients of \eqn{\psi_i} and \eqn{\psi_j} as computed in the reference simplex. Such coefficients can be computed using the functions \code{triMetricSph} and \code{triMetricPull}.
#'
#'@return List with entries:
#' \describe{
#'   \item{\code{Shift}}{Scaled stiffness matrix \eqn{S}}
#'   \item{\code{Scale}}{Scaling matrix \eqn{\hat{C}^{-1/2}}}
#'   \item{\code{Eig}}{Interval containing the eigenvalues of \eqn{S}}
#'   \item{\code{Mass}}{Mass matrix \eqn{C} or its mass-lumped approximation  \eqn{\hat{C}} (stored as an array if mass lumping is applied, and a sparse matrix otherwise)}
#'   \item{\code{Stiff}}{Stiffness matrix \eqn{R}}
#' }
#'
#'
matFEM2d <- function(nodeMat, triMat, triMetricMat, triPotCoeffs = NULL, triDiffCoeffs = NULL, massLumping = TRUE) {
    .Call('_SFEMsim_matFEM2d', PACKAGE = 'SFEMsim', nodeMat, triMat, triMetricMat, triPotCoeffs, triDiffCoeffs, massLumping)
}

#' Mass and stiffness matrices for 1D surfaces
#'
#' Computes the mass and stiffness matrices associated with a second-order elliptic symmetric operator \eqn{L=-\text{div}(A \nabla) + V}.
#'
#'@param nodeMat Array containing the coordinates of the triangulation nodes
#'@param triMat Array containing, for each triangle, the node indices (starting at 1).
#'@param triMetricMat Array containing, for each triangle, the coefficients of the metric tensor of each triangle.
#'@param triPotCoeffs Array containing, for each triangle, the value of the potential function \eqn{V}. If set to \code{NULL} (Default), no potential function is considered.
#'@param triDiffCoeffs Array containing, for each triangle, the coefficients of the modified metric tensor associated with the diffusion matrix \eqn{A}. If set to \code{NULL} (Default), the usual metric is considered (which corresponds to the case where \eq{A} is the identity matrix).
#'@param massLumping logical; TRUE (Default) = Compute mass lumping approximation of mass matrix, FALSE = Compute true mass matrix.
#'
#'@details We consider second-order elliptic symmetric operators \eqn{L} of the form \deqn{L=-\text{div}(A \nabla) + V} where \eqn{V} denotes a so-called potential function taking postive values,
#' \eqn{A} denotes a (linear) operator mapping tangent vectors at a given point to tangent vectors at the same point, \eqn{\test{div}} denotes the divergence operator, and \eqn{\nabla} denotes the gradient operator.
#'
#'@details The function returns the mass and stiffness matrices associated with linear finite elements on a mesh. The mass matrix \eqn{C} contains entries \eqn{[(\psi_i, \psi_j)]_{1 \le i,j \le n}},
#' the mass lumped matrix  \eqn{\hat{C}} is diagonal with entries \eqn{[(\psi_i, 1)]_{1 \le i\le n}},
#' the stiffness matrix \eqn{R} contains entries \eqn{[(V\psi_i, \psi_j)+(A\nabla\psi_i, \nabla\psi_j)]_{1 \le i,j \le n}}
#' The scaled stiffness matrix is defined as \eqn{S=\hat{C}^{-1/2}R\hat{C}^{-1/2}}.
#'
#'@details The coefficients in \code{triMetricMat} can be computed using the function \code{triMetricPull1d}.
#'
#'@details Since we are in 1D, \code{triDiffCoeffs} and \code{triPotCoeffs} are just matrices with a single column and positive values.
#'
#'@details The coefficients in \code{triDiffCoeffs} correspond to the overall tensor, in local coordinates, that allows us to compute the
#'\eqn{(A\nabla\psi_i, \nabla\psi_j)} using the gradients of \eqn{\psi_i} and \eqn{\psi_j} as computed in the reference simplex.
#'
#'@return List with entries:
#' \describe{
#'   \item{\code{Shift}}{Scaled stiffness matrix \eqn{S}}
#'   \item{\code{Scale}}{Scaling matrix \eqn{\hat{C}^{-1/2}}}
#'   \item{\code{Eig}}{Interval containing the eigenvalues of \eqn{S}}
#'   \item{\code{Mass}}{Mass matrix \eqn{C} or its mass-lumped approximation  \eqn{\hat{C}} (stored as an array if mass lumping is applied, and a sparse matrix otherwise)}
#'   \item{\code{Stiff}}{Stiffness matrix \eqn{R}}
#' }
#'
#'
matFEM1d <- function(nodeMat, triMat, triMetricMat, triPotCoeffs = NULL, triDiffCoeffs = NULL, massLumping = TRUE) {
    .Call('_SFEMsim_matFEM1d', PACKAGE = 'SFEMsim', nodeMat, triMat, triMetricMat, triPotCoeffs, triDiffCoeffs, massLumping)
}

